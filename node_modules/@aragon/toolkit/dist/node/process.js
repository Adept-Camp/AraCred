"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startProcess = exports.detachProcess = exports.attachProcess = exports.killProcessTree = exports.getProcessTree = exports.defaultKillSignal = void 0;

var _execa = _interopRequireDefault(require("execa"));

var _util = require("util");

var _psTree = _interopRequireDefault(require("ps-tree"));

var _misc = require("./misc");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
const defaultKillSignal = 'SIGINT';
exports.defaultKillSignal = defaultKillSignal;

const getProcessTree = subprocess => (0, _util.promisify)(_psTree.default)(subprocess.pid);

exports.getProcessTree = getProcessTree;

const killProcessTree = async (subprocess, {
  logger = _misc.noop
}) => {
  const {
    children
  } = await getProcessTree(subprocess);

  if (!children) {
    return;
  }

  children.forEach(child => {
    // each child has the properties: COMMAND, PPID, PID, STAT
    logger(`killing process with PID ${child.pid}, child of ${subprocess.pid}`);
    process.kill(child.PID, defaultKillSignal);
  });
};

exports.killProcessTree = killProcessTree;

const attachProcess = subprocess => {
  subprocess.stdout.pipe(process.stdout);
  subprocess.stderr.pipe(process.stderr);
  process.stdin.pipe(subprocess.stdin);
};

exports.attachProcess = attachProcess;

const detachProcess = subprocess => {
  subprocess.stderr.destroy();
  subprocess.stdout.destroy();
  subprocess.stdin.destroy();
  subprocess.unref();
};

exports.detachProcess = detachProcess;

const startProcess = async ({
  cmd,
  args,
  execaOpts = {},
  readyOutput,
  timeout,
  logger = _misc.noop
}) => {
  let output = '';
  const request = new Promise((resolve, reject) => {
    const subprocess = (0, _execa.default)(cmd, args, execaOpts);
    logger('spawned subprocess with PID: ', subprocess.pid);
    subprocess.stderr.on('data', data => {
      data = data.toString();
      logger(`stderr: ${data}`);
      if (!data.includes('DeprecationWarning')) reject(new Error(data));
    });
    subprocess.stdout.on('data', data => {
      data = data.toString();
      logger(`stdout: ${data}`); // build the output log (to be able to err out if the time is up)

      output = `${output}${data}\n`; // check for ready signal

      if (data.includes(readyOutput)) {
        resolve({
          output,
          kill: () => killProcessTree(subprocess, {
            logger
          }),
          attach: () => attachProcess(subprocess),
          detach: () => detachProcess(subprocess)
        });
      }
    });
  });
  return (0, _misc.withTimeout)(request, timeout, new Error(`Starting the process timed out:\n${output}`));
};

exports.startProcess = startProcess;
//# sourceMappingURL=process.js.map