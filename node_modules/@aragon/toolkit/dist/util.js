"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addressesEqual = addressesEqual;
exports.isValidAragonId = isValidAragonId;
exports.convertDAOIdToSubdomain = convertDAOIdToSubdomain;
exports.getAragonGanacheFiles = exports.getIpfsCacheFiles = exports.getContract = exports.getRecommendedGasLimit = exports.expandLink = exports.isAddress = void 0;

var _path = _interopRequireDefault(require("path"));

var _constants = require("./helpers/constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
function addressesEqual(first, second) {
  first = first && first.toLowerCase();
  second = second && second.toLowerCase();
  return first === second;
}

const isAddress = addr => /0x[a-fA-F0-9]{40}/.test(addr);
/**
 * Validates an Aragon Id
 * @param {string} aragonId Aragon Id
 * @returns {boolean} `true` if valid
 */


exports.isAddress = isAddress;

function isValidAragonId(aragonId) {
  return /^[a-z0-9-]+$/.test(aragonId);
}
/**
 * Convert a DAO id to its subdomain
 * E.g. mydao -> mydao.aragonid.eth
 * @param {string} aragonId Aragon Id
 * @returns {string} DAO subdomain
 */


function convertDAOIdToSubdomain(aragonId) {
  // If already a subdomain, return
  if (new RegExp(`^([a-z0-9-]+).${_constants.ARAGON_DOMAIN}$`).test(aragonId)) return aragonId;
  if (!isValidAragonId(aragonId)) throw new Error(`Invalid DAO Id: ${aragonId}`);
  return `${aragonId}.${_constants.ARAGON_DOMAIN}`;
}

const expandLink = link => {
  const {
    name,
    address
  } = link;
  const placeholder = `__${name}${'_'.repeat(38 - name.length)}`;
  link.placeholder = placeholder;
  link.regex = new RegExp(placeholder, 'g');
  link.addressBytes = address.slice(0, 2) === '0x' ? address.slice(2) : address;
  return link;
};
/**
 *
 * Calculate the recommended gas limit
 *
 * @param {*} web3 eth provider to get the last block gas limit
 * @param {number} estimatedGas estimated gas
 * @param {number} gasFuzzFactor defaults to 1.5
 * @returns {number} gasLimit
 */


exports.expandLink = expandLink;

const getRecommendedGasLimit = async (web3, estimatedGas, gasFuzzFactor = _constants.DEFAULT_GAS_FUZZ_FACTOR) => {
  // TODO print these values if --debug is passed
  const latestBlock = await web3.eth.getBlock('latest');
  const blockGasLimit = latestBlock.gasLimit;
  const upperGasLimit = Math.round(blockGasLimit * _constants.LAST_BLOCK_GAS_LIMIT_FACTOR);
  if (estimatedGas > upperGasLimit) return estimatedGas; // TODO print a warning?

  const bufferedGasLimit = Math.round(estimatedGas * gasFuzzFactor);
  if (bufferedGasLimit < upperGasLimit) return bufferedGasLimit;
  return upperGasLimit;
};

exports.getRecommendedGasLimit = getRecommendedGasLimit;

const getContract = (pkg, contract) => {
  const artifact = require(`${pkg}/build/contracts/${contract}.json`);

  return artifact;
};

exports.getContract = getContract;

const getIpfsCacheFiles = () => {
  return _path.default.resolve(require.resolve('@aragon/aragen'), '../ipfs-cache');
};

exports.getIpfsCacheFiles = getIpfsCacheFiles;

const getAragonGanacheFiles = () => {
  return _path.default.resolve(require.resolve('@aragon/aragen'), '../aragon-ganache');
};

exports.getAragonGanacheFiles = getAragonGanacheFiles;
//# sourceMappingURL=util.js.map