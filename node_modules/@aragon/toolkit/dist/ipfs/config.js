"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultRepoPath = getDefaultRepoPath;
exports.getPeerIDConfig = getPeerIDConfig;
exports.getPorts = getPorts;
exports.getRepoVersion = getRepoVersion;
exports.getRepoSize = getRepoSize;
exports.getRepoConfig = getRepoConfig;
exports.patchRepoConfig = patchRepoConfig;
exports.setPorts = exports.ensureRepoInitialized = exports.configureCors = exports.isCorsConfigured = void 0;

var _path = _interopRequireWildcard(require("path"));

var _fsExtra = require("fs-extra");

var _getFolderSize = _interopRequireDefault(require("get-folder-size"));

var _fs = require("fs");

var _os = require("os");

var _byteSize = _interopRequireDefault(require("byte-size"));

var _execa = _interopRequireDefault(require("execa"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

//
const isCorsConfigured = async httpClient => {
  const conf = await httpClient.config.get('API.HTTPHeaders');
  const allowOrigin = CorsAllowAll[0].key.split('.').pop();
  const allowMethods = CorsAllowAll[1].key.split('.').pop();

  if (conf && conf[allowOrigin] && conf[allowMethods]) {
    return true;
  } else {
    throw new Error(`Please set the following flags in your IPFS node:
    ${CorsAllowAll.map(({
      key,
      value
    }) => {
      return `${key}: ${value}`;
    }).join('\n    ')}`);
  }
};

exports.isCorsConfigured = isCorsConfigured;

const configureCors = async httpClient => {
  return Promise.all(CorsAllowAll.map(({
    key,
    value
  }) => httpClient.config.set(key, value)));
};

exports.configureCors = configureCors;
const CorsAllowAll = [{
  key: 'API.HTTPHeaders.Access-Control-Allow-Origin',
  value: ['*']
}, {
  key: 'API.HTTPHeaders.Access-Control-Allow-Methods',
  value: ['PUT', 'GET', 'POST']
}];

const ensureRepoInitialized = async (binPath, repoPath) => {
  if (!binPath) {
    throw new Error(_constants.NO_INSTALLATION_MSG);
  }

  if (!(0, _fs.existsSync)(_path.default.resolve(repoPath))) {
    await (0, _execa.default)(binPath, ['init'], {
      env: {
        IPFS_PATH: repoPath
      }
    });
  }
};

exports.ensureRepoInitialized = ensureRepoInitialized;

const setPorts = async (repoPath, apiPort, gatewayPort, swarmPort) => {
  await patchRepoConfig(repoPath, {
    Addresses: {
      API: `/ip4/0.0.0.0/tcp/${apiPort}`,
      Announce: [],
      Gateway: `/ip4/0.0.0.0/tcp/${gatewayPort}`,
      NoAnnounce: [],
      Swarm: [`/ip4/0.0.0.0/tcp/${swarmPort}`, `/ip6/::/tcp/${swarmPort}`]
    }
  });
};

exports.setPorts = setPorts;

function getDefaultRepoPath() {
  const homedirPath = (0, _os.homedir)();
  return (0, _path.join)(homedirPath, '.ipfs');
}

function getPeerIDConfig(repoConfig) {
  return repoConfig.Identity.PeerID;
}

function getPorts(repoConfig) {
  return {
    // default: "/ip4/127.0.0.1/tcp/5001"
    api: repoConfig.Addresses.API.split('/').pop(),
    // default: "/ip4/127.0.0.1/tcp/8080"
    gateway: repoConfig.Addresses.Gateway.split('/').pop(),
    // default: [
    //   "/ip4/0.0.0.0/tcp/4001"
    //   "/ip6/::/tcp/4001"
    // ]
    swarm: repoConfig.Addresses.Swarm[0].split('/').pop()
  };
}

async function getRepoVersion(repoPath) {
  const versionFilePath = (0, _path.join)(repoPath, 'version');
  const version = await (0, _fsExtra.readJson)(versionFilePath);
  return version;
}

async function getRepoSize(repoPath) {
  return new Promise((resolve, reject) => {
    (0, _getFolderSize.default)(repoPath, (err, size) => {
      if (err) {
        reject(err);
      } else {
        const humanReadableSize = (0, _byteSize.default)(size);
        resolve(humanReadableSize);
      }
    });
  });
}

async function getRepoConfig(repoPath) {
  const configFilePath = (0, _path.join)(repoPath, 'config');
  const config = await (0, _fsExtra.readJson)(configFilePath);
  return config;
}

async function patchRepoConfig(repoPath, patch) {
  const configFilePath = (0, _path.join)(repoPath, 'config');
  const repoConfig = await (0, _fsExtra.readJson)(configFilePath);

  if (!repoConfig) {
    throw new Error(`Cannot read the config file at: ${configFilePath}`);
  }

  const nextConfig = Object.assign(repoConfig, patch);
  await (0, _fsExtra.writeJson)(configFilePath, nextConfig, {
    spaces: 2
  });
  return nextConfig;
}
//# sourceMappingURL=config.js.map