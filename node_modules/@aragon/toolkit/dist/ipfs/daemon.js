"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLocalDaemonRunning = exports.startLocalDaemon = exports.getBinaryPath = void 0;

var _misc = require("./misc");

var _node = require("../node");

var _constants = require("./constants");

const getBinaryPath = () => (0, _node.getBinary)('ipfs', (0, _node.getPackageRoot)(__dirname));

exports.getBinaryPath = getBinaryPath;

const startLocalDaemon = (binPath, repoPath, options = {}) => {
  if (!binPath) {
    throw new Error(_constants.NO_INSTALLATION_MSG);
  }

  const processSetup = {
    cmd: binPath,
    args: ['daemon', ..._constants.DEFAULT_DAEMON_ARGS],
    execaOpts: {
      detached: options.detached,
      env: {
        IPFS_PATH: repoPath
      }
    },
    readyOutput: _constants.DAEMON_READY_OUTPUT,
    timeout: _constants.DAEMON_START_TIMEOUT,
    logger: options.logger
  };
  return (0, _node.startProcess)(processSetup);
};
/**
 * Check whether the daemon is running by connecting to the API.
 *
 * @param {URL} address a `URL` object
 * @returns {boolean} true if it is running
 */


exports.startLocalDaemon = startLocalDaemon;

const isLocalDaemonRunning = async address => {
  address = address || {
    protocol: 'http',
    host: '127.0.0.1',
    port: 5001
  };
  const portTaken = await (0, _node.isPortTaken)(address.port);

  if (!portTaken) {
    return false;
  }

  try {
    // if port is taken, connect to the API,
    // otherwise we can assume the port is taken by a different process
    await (0, _misc.connectOrThrow)(address);
    return true;
  } catch (e) {
    return false;
  }
};

exports.isLocalDaemonRunning = isLocalDaemonRunning;
//# sourceMappingURL=daemon.js.map