"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connectOrThrow = connectOrThrow;
exports.connectThroughHTTP = connectThroughHTTP;
exports.parseAddressAsURL = parseAddressAsURL;
exports.getDistName = exports.cleanVersion = exports.getHttpClient = exports.ensureLocalDaemon = void 0;

var _ipfsHttpClient = _interopRequireDefault(require("ipfs-http-client"));

var _url = _interopRequireDefault(require("url"));

var _fsExtra = require("fs-extra");

var _node = require("../node");

var _config = require("./config");

var _aragon = require("./aragon");

var _daemon = require("./daemon");

var _install = require("./install");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: import only submodules?
const ensureLocalDaemon = async ({
  projectPath,
  binPath,
  repoPath,
  apiPort,
  gatewayPort,
  swarmPort,
  logger = _node.noop
}) => {
  /**
   * Ensure project
   */
  if (await (0, _fsExtra.exists)(projectPath)) {
    logger(`Project already initialized: ${projectPath}`);
  } else {
    logger(`Project initializing: ${projectPath}`);
    await (0, _node.initPackage)(projectPath);
  }
  /**
   * Ensure binaries
   */


  if (await (0, _fsExtra.exists)(binPath)) {
    logger(`Go-ipfs already installed: ${projectPath}`);
  } else {
    logger(`Go-ipfs installing: ${projectPath}`);
    await (0, _install.installGoIpfs)(true, projectPath);
    logger(`Go-ipfs installed: ${projectPath}`);
  }
  /**
   * Ensure daemon running
   */


  const apiAddress = {
    protocol: 'http',
    port: apiPort,
    host: '127.0.0.1'
  };

  if (await (0, _daemon.isLocalDaemonRunning)(apiAddress)) {
    logger(`Daemon already started on port: ${apiPort}`);
    return;
  }

  logger(`Daemon starting on port: ${apiPort}`);

  try {
    await (0, _config.ensureRepoInitialized)(binPath, repoPath);
    await (0, _config.setPorts)(repoPath, apiPort, gatewayPort, swarmPort);
    const processController = await (0, _daemon.startLocalDaemon)(binPath, repoPath, {
      detached: true,
      logger
    });
    processController.detach();
    logger(`Daemon started on port: ${apiPort}`);
    const httpClient = await getHttpClient(`http://localhost:${apiPort}`);
    await (0, _config.configureCors)(httpClient);
    await (0, _aragon.pinArtifacts)(httpClient);
    logger('Daemon ready!!');
  } catch (err) {
    logger('Daemon failed to start...');
  }
};

exports.ensureLocalDaemon = ensureLocalDaemon;

const getHttpClient = async address => {
  // try {
  return connectOrThrow(address); // } catch (err) {
  // if (!address.includes('localhost')) {
  //   throw err
  // }
  // // connecting locally failed
  // const startAndRetry = await askForConfirmation(
  //   'The local IPFS Daemon is not running, do you wish to start it?'
  // )
  // if (startAndRetry) {
  //   await startLocalDaemon()
  //   return getHttpClient(address)
  // }
  // }
};

exports.getHttpClient = getHttpClient;

async function connectOrThrow(address) {
  try {
    const httpClient = connectThroughHTTP(address);
    await httpClient.version();
    return httpClient;
  } catch (err) {
    throw new Error(`Could not connect to the IPFS API at ${JSON.stringify(address)}`);
  }
}

function connectThroughHTTP(address) {
  if (typeof address === 'string') {
    return (0, _ipfsHttpClient.default)(parseAddressAsURL(address));
  }

  return (0, _ipfsHttpClient.default)(address);
}

function parseAddressAsURL(address) {
  const uri = new _url.default.URL(address);
  return {
    protocol: uri.protocol.replace(':', ''),
    host: uri.hostname,
    port: parseInt(uri.port)
  };
} // https://github.com/ipfs/npm-go-ipfs/blob/master/link-ipfs.js#L8
// https://github.com/ipfs/npm-go-ipfs#publish-a-new-version-of-this-module-with-exact-same-go-ipfs-version


const cleanVersion = version => version.replace(/-hacky[0-9]+/, '');

exports.cleanVersion = cleanVersion;

const getDistName = (version, os, arch) => `go-ipfs_v${version}_${os}-${arch}.tar.gz`;

exports.getDistName = getDistName;
//# sourceMappingURL=misc.js.map