"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.propagateFile = propagateFile;
exports.propagateFiles = propagateFiles;

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _node = require("../node");

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
async function queryCidAtGateway(gateway, cid) {
  try {
    await (0, _node.withTimeout)((0, _nodeFetch.default)(`${gateway}/${cid}`), _constants.GATEWAY_FETCH_TIMEOUT, new Error(_constants.GATEWAY_FETCH_TIMEOUT_MSG));
    return {
      success: true,
      cid,
      gateway
    };
  } catch (err) {
    return {
      success: false,
      cid,
      gateway,
      error: err
    };
  }
}

async function propagateFile(cid, options = {}) {
  const {
    progressCallback = _node.noop,
    gateways = _constants.DEFAULT_GATEWAYS
  } = options;
  const results = await Promise.all(gateways.map(gateway => queryCidAtGateway(gateway, cid)));
  const succeeded = results.filter(status => status.success).length;
  const failed = gateways.length - succeeded;
  progressCallback(1, {
    cid,
    succeeded,
    failed
  });
  const errors = results.filter(result => result.error).map(result => result.error);
  return {
    succeeded,
    failed,
    errors
  };
}

async function propagateFiles(CIDs, options = {}) {
  const results = await Promise.all(CIDs.map(cid => propagateFile(cid, options)));
  const {
    gateways = _constants.DEFAULT_GATEWAYS
  } = options;
  return {
    gateways,
    succeeded: results.reduce((prev, current) => prev + current.succeeded, 0),
    failed: results.reduce((prev, current) => prev + current.failed, 0),
    errors: results.reduce((prev, current) => [...prev, ...current.errors], [])
  };
}
//# sourceMappingURL=propagation.js.map