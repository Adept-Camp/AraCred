"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveEnsDomain = resolveEnsDomain;
exports.initAragonJS = initAragonJS;
exports.getApps = getApps;
exports.getTransactionPath = getTransactionPath;

var _wrapper = _interopRequireWildcard(require("@aragon/wrapper"));

var _operators = require("rxjs/operators");

var _util = require("../util");

var _node = require("../node");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const subscribe = (wrapper, {
  onApps,
  onForwarders,
  onTransaction,
  onPermissions
}) => {
  const {
    apps,
    forwarders,
    transactions,
    permissions
  } = wrapper;
  const subscriptions = {
    apps: apps.subscribe(onApps),
    connectedApp: null,
    forwarders: forwarders.subscribe(onForwarders),
    transactions: transactions.subscribe(onTransaction),
    permissions: permissions.subscribe(onPermissions)
  };
  return subscriptions;
};
/**
 * Resolve an ens domain
 *
 * @param {string} domain Domain
 * @param {*} opts Options
 * @returns {Promise<string>} Resolved ens domain
 */


async function resolveEnsDomain(domain, opts) {
  try {
    return await (0, _wrapper.ensResolve)(domain, opts);
  } catch (err) {
    if (err.message === 'ENS name not defined.') {
      return '';
    }

    throw err;
  }
}
/**
 * Initialize the Aragon.js wrapper and subscribe to the `apps`,
 * `forwarders`, `transactions` and `permissions` observables.
 *
 * @param {string} dao DAO address
 * @param {string} ensRegistryAddress ENS Registry address
 * @param {Object} options Options
 * @param {Object} options.provider Eth provider
 * @param {string} options.gasPrice Gas price
 * @param {string} options.accounts Eth accounts
 * @param {Object} options.ipfsConf IPFS configuration
 * @param {function} options.onApps Apps callback
 * @param {function} options.onForwarders Forwarders callback
 * @param {function} options.onTransaction Transaction callback
 * @param {function} options.onDaoAddress Dao address callback
 * @param {function} options.onPermissions Permissions callback
 * @returns {Promise<Aragon>} Aragon wrapper with an added `cancel` function
 */


async function initAragonJS(dao, ensRegistryAddress, {
  provider,
  gasPrice,
  accounts = '',
  ipfsConf = {},
  onApps = _node.noop,
  onForwarders = _node.noop,
  onTransaction = _node.noop,
  onDaoAddress = _node.noop,
  onPermissions = _node.noop
} = {}) {
  const isDomain = dao => /[a-z0-9]+\.eth/.test(dao);

  const daoAddress = isDomain(dao) ? await resolveEnsDomain(dao, {
    provider,
    registryAddress: ensRegistryAddress
  }) : dao;

  if (!daoAddress) {
    throw new Error('The provided DAO address is invalid');
  }

  onDaoAddress(daoAddress); // TODO: don't reinitialize if cached

  const wrapper = new _wrapper.default(daoAddress, {
    provider,
    defaultGasPriceFn: () => gasPrice,
    apm: {
      ipfs: ipfsConf,
      ensRegistryAddress
    }
  });

  try {
    await wrapper.init({
      accounts: {
        providedAccounts: accounts
      }
    });
  } catch (err) {
    if (err.message === 'connection not open') {
      throw new Error('The wrapper cannot be initialized without a connection');
    }

    throw err;
  }

  const subscriptions = subscribe(wrapper, {
    onApps,
    onForwarders,
    onTransaction,
    onPermissions
  }, {
    ipfsConf
  });

  wrapper.cancel = () => {
    Object.values(subscriptions).forEach(subscription => {
      if (subscription) {
        subscription.unsubscribe();
      }
    });
  };

  return wrapper;
}
/**
 * Return a list of all installed apps.
 * @param {Aragon} wrapper Aragon wrapper
 * @returns {Promise<Object[]>} Installed apps
 */


async function getApps(wrapper) {
  return wrapper.apps // If the app list contains a single app, wait for more
  .pipe((0, _operators.takeWhile)(apps => apps.length <= 1, true)).toPromise();
}
/**
 * Get transaction path on an Aragon app for `method` with `params`
 * as parameters. Wait for apps to load before calling
 * wrapper's `getTransactionPath`. If app is the ACL, call
 * `getACLTransactionPath`.
 *
 * @param {string} appAddress App address
 * @param {string} method Method name
 * @param {Array<*>} params Method params
 * @param {Aragon} wrapper Aragon wrapper
 * @returns {Promise<Object>} Transaction path
 */


async function getTransactionPath(appAddress, method, params, wrapper) {
  // Wait for app info to load
  const app = await wrapper.apps.pipe( // If the app list contains a single app, wait for more
  (0, _operators.takeWhile)(apps => apps.length <= 1, true), (0, _operators.map)(apps => apps.find(app => (0, _util.addressesEqual)(appAddress, app.proxyAddress))), (0, _operators.filter)(app => app), (0, _operators.defaultIfEmpty)(null), // If app is not found, default to null
  (0, _operators.first)()).toPromise();
  if (!app) throw new Error(`Can't find app ${appAddress}.`); // If app is the ACL, call getACLTransactionPath

  return appAddress === wrapper.aclProxy.address ? wrapper.getACLTransactionPath(method, params) : wrapper.getTransactionPath(appAddress, method, params);
}
//# sourceMappingURL=aragonjs-wrapper.js.map