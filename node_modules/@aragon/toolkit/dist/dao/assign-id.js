"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assignId = assignId;
exports.isIdAssigned = isIdAssigned;

var _ethereumEns = _interopRequireDefault(require("ethereum-ens"));

var _web3Utils = require("web3-utils");

var _IFIFSResolvingRegistrar = require("@aragon/abis/id/artifacts/IFIFSResolvingRegistrar");

var _constants = require("../helpers/constants");

var _util = require("../util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function assignId(daoAddress, daoId, options) {
  const {
    web3,
    ensRegistry,
    gasPrice
  } = options;
  if (!(0, _web3Utils.isAddress)(daoAddress)) throw new Error(`Invalid address: ${daoAddress}`);
  const ens = new _ethereumEns.default(web3.currentProvider, ensRegistry);
  const registrar = new web3.eth.Contract(_IFIFSResolvingRegistrar.abi, (await ens.owner(_constants.ARAGON_DOMAIN)));
  await registrar.methods.register((0, _web3Utils.sha3)(daoId), daoAddress).send({
    from: (await web3.eth.getAccounts())[0],
    gas: _constants.REGISTRAR_GAS_LIMIT,
    gasPrice
  });
}
/**
 * Return true if `id` is assigned to an organization
 *
 * @param {string} daoId Aragon DAO id
 * @param {Object} options Options
 * @param {Object} options.web3 web3
 * @param {string} options.ensRegistry ENS registry address
 * @returns {Promise<boolean>} true if already assigned
 */


async function isIdAssigned(daoId, options) {
  const daoUrl = (0, _util.convertDAOIdToSubdomain)(daoId);
  const ens = new _ethereumEns.default(options.web3.currentProvider, options.ensRegistry); // The only way to know if a domain is not registered is to call
  // `resolver().addr()` and check if it throws

  try {
    return Boolean((await ens.resolver(daoUrl).addr()));
  } catch (err) {
    // throws an ENS.NameNotFound error if name doesn't exist
    if (err !== _ethereumEns.default.NameNotFound) throw err;
    return false;
  }
}
//# sourceMappingURL=assign-id.js.map