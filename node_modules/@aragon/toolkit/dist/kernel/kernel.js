"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAclAddress = getAclAddress;
exports.getAppProxyAddressFromReceipt = getAppProxyAddressFromReceipt;
exports.getBasesNamespace = getBasesNamespace;
exports.getAppBase = getAppBase;

var _web3EthAbi = _interopRequireDefault(require("web3-eth-abi"));

var _Kernel = require("@aragon/abis/os/artifacts/Kernel");

var _util = require("../util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const newAppProxyLogName = 'NewAppProxy';

const newAppProxyLogAbi = _Kernel.abi.find(({
  type,
  name
}) => type === 'event' && name === newAppProxyLogName); // This check is run outside the function body so it can be catched
// on every any run when it happens, instead on a specific function call


if (!newAppProxyLogAbi) {
  throw new Error(`aragonCLI is out of sync with aragon/os, please report this issue:
Kernel ABI does not include expected log '${newAppProxyLogName}'`);
}
/**
 * Returns aclAddress for a DAO
 *
 * @param {string} dao DAO address
 * @param {Object} web3 Web3 initialized object
 * @return {Promise<string>} aclAddress
 */


async function getAclAddress(dao, web3) {
  const daoInstance = new web3.eth.Contract(_Kernel.abi, dao);
  return daoInstance.methods.acl().call();
}
/**
 * Returns new app proxy contract address
 *
 * @param {string} dao DAO address
 * @param {Object} receipt Web3 receipt object
 * @return {string|undefined} app proxy contract address
 */


function getAppProxyAddressFromReceipt(dao, receipt) {
  const logTopic = _web3EthAbi.default.encodeEventSignature(newAppProxyLogAbi);

  const deployLog = receipt.logs.find(({
    topics,
    address
  }) => {
    return topics[0] === logTopic && (0, _util.addressesEqual)(dao, address);
  });
  if (!deployLog) return;

  const log = _web3EthAbi.default.decodeLog(newAppProxyLogAbi.inputs, deployLog.data);

  if (!log.proxy) throw new Error(`aragonCLI is out of sync with aragon/os, please report this issue:
Kernel ABI log ${newAppProxyLogName} does not have expected argument 'log'`);
  return log.proxy;
}
/**
 * Returns the current app base address for an appId
 *
 * @param {string} dao DAO address
 * @param {string} appId APP id to get the base of
 * @param {Object} web3 Web3 initialized object
 * @return {Promise<string>} basesNamespace
 */


async function getBasesNamespace(dao, web3) {
  const kernel = new web3.eth.Contract(_Kernel.abi, dao);
  return kernel.methods.APP_BASES_NAMESPACE().call();
}
/**
 * Returns the current app base address for an appId
 *
 * @param {string} dao DAO address
 * @param {string} appId APP id to get the base of
 * @param {Object} web3 Web3 initialized object
 * @return {Promise<string>} currentBaseAddress
 */


async function getAppBase(dao, appId, web3) {
  const kernel = new web3.eth.Contract(_Kernel.abi, dao);
  const basesNamespace = await getBasesNamespace(dao, web3);
  return kernel.methods.getApp(basesNamespace, appId).call();
}
//# sourceMappingURL=kernel.js.map